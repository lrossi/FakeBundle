import Foundation

// MARK: - Code Generation

func makeDirectoryCode(name: String, filename: String, childrenCreation: String, childrenClasses: String) -> String {
    return """
    class \(name): Directory {
        var filename: String = "\(filename)"
        lazy var children: [FileType] = {
            return [\(childrenCreation)]
        }()
    
        \(childrenClasses)
    }
    
    """
}

func makeFileCode(name: String, filename: String, contentsBase64: String) -> String {
    return """
    class \(name): File {
        var filename: String = "\(filename)"
        lazy var contentsBase64: String = {
            return "\(contentsBase64)"
        }()
    }
    
    """
}

// MARK: - File traversal logic

func makeTypeName(filename: String) -> String {
    return filename.replacingOccurrences(of: ".", with: "_").replacingOccurrences(of: " ", with: "__").replacingOccurrences(of: "-", with: "___").replacingOccurrences(of: "@", with: "____").capitalized
}

func generateCode(inputUrl: URL, outputUrl: URL) throws {
    let fm = FileManager.default
    
    func directoryAsCode(of url: URL) throws -> String {
        let children = try fm.contentsOfDirectory(at: url, includingPropertiesForKeys: [], options: [.skipsSubdirectoryDescendants, .skipsHiddenFiles])
        
        var childrenTypes = [String]()
        let childrenClassesString = try children.map { url -> String in
            var isDirectory: ObjCBool = false
            guard fm.fileExists(atPath: url.path, isDirectory: &isDirectory) else {
                return ""
            }
            
            let filename = url.lastPathComponent
            let type = makeTypeName(filename: filename)
            
            guard !isDirectory.boolValue else {
                let code = try directoryAsCode(of: url)
                if !code.isEmpty {
                    // Only add to children if we could actually generate the type for the dir
                    childrenTypes.append("\(type)()")
                }
                return code
            }
            
            // Single file
            guard let data = fm.contents(atPath: url.path) else {
                return ""
            }
            
            let code = makeFileCode(name: type, filename: filename, contentsBase64: data.base64EncodedString())
            if !code.isEmpty {
                // Only add to children if we could actually generate the type for the file
                childrenTypes.append("\(type)()")
            }
            return code
        }.joined(separator: "\n\n")
        
        let filename = url.lastPathComponent
        let name = makeTypeName(filename: filename)
        let childrenCreation = childrenTypes.joined(separator: ", ")
        return makeDirectoryCode(name: name, filename: filename, childrenCreation: childrenCreation, childrenClasses: childrenClassesString)
    }
    
    let fileContents = fileHeader + (try directoryAsCode(of: inputUrl))
    try fileContents.data(using: .utf8)?.write(to: outputUrl)
}

// MARK: - Header

let fileHeader = """
//
//  FakeBundle.swift
//
//  Generated by FakeBundle
//  See https://github.com/zweigraf/FakeBundle
//

import Foundation

protocol FileType {
    var isDirectory: Bool { get }
    var filename: String { get }
    func export(to path: String) throws
}
protocol File: FileType {
    var contentsBase64: String { get }
}
extension File {
    var isDirectory: Bool {
        return false
    }
    var contents: Data? {
        return Data(base64Encoded: contentsBase64)
    }

    func export(to path: String) throws {
        guard let contents = contents else { return }
        let originalUrl = URL(fileURLWithPath: path)
        let myUrl = originalUrl.appendingPathComponent(filename)
        try contents.write(to: myUrl)
    }
}
protocol Directory: FileType {
    var children: [FileType] { get }
}
extension Directory {
    var isDirectory: Bool {
        return true
    }
    func export(to path: String) throws {
        let originalUrl = URL(fileURLWithPath: path)
        let myUrl = originalUrl.appendingPathComponent(filename)
        try FileManager.default.createDirectory(at: myUrl, withIntermediateDirectories: true, attributes: nil)
        try children.forEach { try $0.export(to: myUrl.path) }
    }
}

"""
